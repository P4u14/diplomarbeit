<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SegmentationRunner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SegmentationRunner.py" />
              <option name="originalContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
              <option name="updatedContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualize.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualize.py" />
              <option name="originalContent" value="import os&#10;import glob&#10;import pandas as pd&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;&#10;def sanitize_filename(name: str) -&gt; str:&#10;    return name.replace(' ', '_').replace('/', '_')&#10;&#10;&#10;def main():&#10;    # Path to mean CSV files&#10;    pattern = os.path.join('data', 'Validation_Results', '*_mean.csv')&#10;    files = glob.glob(pattern)&#10;    if not files:&#10;        print('No mean CSV files found')&#10;        return&#10;&#10;    # Load all dataframes keyed by experiment name&#10;    data = {}&#10;    for fp in files:&#10;        exp = os.path.basename(fp).replace('_mean.csv', '')&#10;        df = pd.read_csv(fp)&#10;        data[exp] = df&#10;&#10;    # Determine datasets and metrics&#10;    sample_df = next(iter(data.values()))&#10;    datasets = sample_df['Dataset'].tolist()&#10;    metrics = [c for c in sample_df.columns if c != 'Dataset']&#10;    # Separate special metrics for combined plot&#10;    paired_metrics = [&#10;        'Mean Number of GT Segments',&#10;        'Mean Number of Segmentation Segments'&#10;    ]&#10;    other_metrics = [m for m in metrics if m not in paired_metrics]&#10;    metrics = other_metrics&#10;&#10;    # Create output directory&#10;    outdir = 'data/Validation_Results/plots'&#10;    os.makedirs(outdir, exist_ok=True)&#10;&#10;    # Generate bar charts&#10;    for dataset in datasets:&#10;        for metric in metrics:&#10;            values = []&#10;            exps = []&#10;            for exp, df in data.items():&#10;                # Get value for this dataset and metric&#10;                row = df.loc[df['Dataset'] == dataset]&#10;                if not row.empty:&#10;                    val = row.iloc[0][metric]&#10;                    values.append(val)&#10;                    exps.append(exp)&#10;            if not values:&#10;                continue&#10;&#10;            # Sortiere Experimente alphabetisch&#10;            pairs = sorted(zip(exps, values), key=lambda x: x[0])&#10;            exps, values = zip(*pairs)&#10;&#10;            plt.figure()&#10;            # Achse bei y=0 zeichnen&#10;            plt.axhline(0, color='black', linewidth=0.8)&#10;            plt.bar(exps, values)&#10;            plt.title(f&quot;{metric} for {dataset}&quot;)&#10;            plt.xlabel('Experiment')&#10;            plt.ylabel(metric)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;&#10;            fname = f&quot;{sanitize_filename(dataset)}_{sanitize_filename(metric)}.png&quot;&#10;            plt.savefig(os.path.join(outdir, fname))&#10;            plt.close()&#10;&#10;    print(f&quot;Plots saved in {outdir}&quot;)&#10;&#10;    # Combined bar charts for GT vs Segmentation segments&#10;    for dataset in datasets:&#10;        exps = []&#10;        vals_gt = []&#10;        vals_seg = []&#10;        for exp, df in data.items():&#10;            row = df.loc[df['Dataset'] == dataset]&#10;            if not row.empty:&#10;                exps.append(exp)&#10;                vals_gt.append(row.iloc[0][paired_metrics[0]])&#10;                vals_seg.append(row.iloc[0][paired_metrics[1]])&#10;        if not exps:&#10;            continue&#10;        # Sort experiments alphabetically&#10;        combined = sorted(zip(exps, vals_gt, vals_seg), key=lambda x: x[0])&#10;        exps, vals_gt, vals_seg = zip(*combined)&#10;&#10;        x = np.arange(len(exps))&#10;        width = 0.35&#10;        fig, ax = plt.subplots()&#10;        ax.axhline(0, color='black', linewidth=0.8)&#10;        ax.bar(x - width/2, vals_gt, width, label=paired_metrics[0])&#10;        ax.bar(x + width/2, vals_seg, width, label=paired_metrics[1])&#10;        ax.set_xticks(x)&#10;        ax.set_xticklabels(exps, rotation=45, ha='right')&#10;        ax.set_title(f&quot;GT vs Segmentation Segments for {dataset}&quot;)&#10;        ax.set_xlabel('Experiment')&#10;        ax.set_ylabel('Mean Number of Segments')&#10;        ax.legend()&#10;        plt.tight_layout()&#10;        fname = f&quot;{sanitize_filename(dataset)}_GT_vs_Segments.png&quot;&#10;        plt.savefig(os.path.join(outdir, fname))&#10;        plt.close()&#10;    print(f&quot;Combined segment plots saved in {outdir}&quot;)&#10;&#10;    # Combined bar charts for dimple center deviations&#10;    dimple_metrics = [&#10;        'Mean Dimples Center Left Deviation',&#10;        'Mean Dimples Center Right Deviation',&#10;        'Mean Dimples Center Left Deviation Abs',&#10;        'Mean Dimples Center Right Deviation Abs'&#10;    ]&#10;    for dataset in datasets:&#10;        exps = []&#10;        vals = {m: [] for m in dimple_metrics}&#10;        for exp, df in data.items():&#10;            row = df.loc[df['Dataset'] == dataset]&#10;            if not row.empty:&#10;                exps.append(exp)&#10;                for m in dimple_metrics:&#10;                    vals[m].append(row.iloc[0][m])&#10;        if not exps:&#10;            continue&#10;        # Sort experiments alphabetically&#10;        combined = sorted(zip(exps, *(vals[m] for m in dimple_metrics)), key=lambda x: x[0])&#10;        sorted_exps = [c[0] for c in combined]&#10;        sorted_vals = [list(c[i] for c in combined) for i in range(1, len(dimple_metrics)+1)]&#10;&#10;        x = np.arange(len(sorted_exps))&#10;        total_width = 0.8&#10;        width = total_width / len(dimple_metrics)&#10;        fig, ax = plt.subplots()&#10;        ax.axhline(0, color='black', linewidth=0.8)&#10;        for i, m in enumerate(dimple_metrics):&#10;            ax.bar(x - total_width/2 + width*i + width/2, sorted_vals[i], width, label=m)&#10;        ax.set_xticks(x)&#10;        ax.set_xticklabels(sorted_exps, rotation=45, ha='right')&#10;        ax.set_title(f&quot;Dimple Center Deviations for {dataset}&quot;)&#10;        ax.set_xlabel('Experiment')&#10;        ax.set_ylabel('Deviation')&#10;        ax.legend()&#10;        plt.tight_layout()&#10;        fname = f&quot;{sanitize_filename(dataset)}_dimple_deviation.png&quot;&#10;        plt.savefig(os.path.join(outdir, fname))&#10;        plt.close()&#10;    print(f&quot;Combined dimple deviation plots saved in {outdir}&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
              <option name="updatedContent" value="import os&#10;import glob&#10;import pandas as pd&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;&#10;&#10;def sanitize_filename(name: str) -&gt; str:&#10;    return name.replace(' ', '_').replace('/', '_')&#10;&#10;&#10;def main():&#10;    # Path to mean CSV files&#10;    pattern = os.path.join('data', 'Validation_Results', '*_mean.csv')&#10;    files = glob.glob(pattern)&#10;    if not files:&#10;        print('No mean CSV files found')&#10;        return&#10;&#10;    # Load all dataframes keyed by experiment name&#10;    data = {}&#10;    for fp in files:&#10;        exp = os.path.basename(fp).replace('_mean.csv', '')&#10;        df = pd.read_csv(fp)&#10;        data[exp] = df&#10;&#10;    # Determine datasets and metrics&#10;    sample_df = next(iter(data.values()))&#10;    datasets = sample_df['Dataset'].tolist()&#10;    metrics = [c for c in sample_df.columns if c != 'Dataset']&#10;    # Separate special metrics for combined plot&#10;    paired_metrics = [&#10;        'Mean Number of GT Segments',&#10;        'Mean Number of Segmentation Segments'&#10;    ]&#10;    other_metrics = [m for m in metrics if m not in paired_metrics]&#10;    metrics = other_metrics&#10;&#10;    # Create output directory&#10;    outdir = 'data/Validation_Results/plots'&#10;    os.makedirs(outdir, exist_ok=True)&#10;&#10;    # Generate bar charts&#10;    for dataset in datasets:&#10;        for metric in metrics:&#10;            values = []&#10;            exps = []&#10;            for exp, df in data.items():&#10;                # Get value for this dataset and metric&#10;                row = df.loc[df['Dataset'] == dataset]&#10;                if not row.empty:&#10;                    val = row.iloc[0][metric]&#10;                    values.append(val)&#10;                    exps.append(exp)&#10;            if not values:&#10;                continue&#10;&#10;            # Sortiere Experimente alphabetisch&#10;            pairs = sorted(zip(exps, values), key=lambda x: x[0])&#10;            exps, values = zip(*pairs)&#10;&#10;            plt.figure()&#10;            # Achse bei y=0 zeichnen&#10;            plt.axhline(0, color='black', linewidth=0.8)&#10;            plt.bar(exps, values)&#10;            plt.title(f&quot;{metric} for {dataset}&quot;)&#10;            plt.xlabel('Experiment')&#10;            plt.ylabel(metric)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;&#10;            fname = f&quot;{sanitize_filename(dataset)}_{sanitize_filename(metric)}.png&quot;&#10;            plt.savefig(os.path.join(outdir, fname))&#10;            plt.close()&#10;&#10;    print(f&quot;Plots saved in {outdir}&quot;)&#10;&#10;    # Combined bar charts for GT vs Segmentation segments&#10;    for dataset in datasets:&#10;        exps = []&#10;        vals_gt = []&#10;        vals_seg = []&#10;        for exp, df in data.items():&#10;            row = df.loc[df['Dataset'] == dataset]&#10;            if not row.empty:&#10;                exps.append(exp)&#10;                vals_gt.append(row.iloc[0][paired_metrics[0]])&#10;                vals_seg.append(row.iloc[0][paired_metrics[1]])&#10;        if not exps:&#10;            continue&#10;        # Sort experiments alphabetically&#10;        combined = sorted(zip(exps, vals_gt, vals_seg), key=lambda x: x[0])&#10;        exps, vals_gt, vals_seg = zip(*combined)&#10;&#10;        x = np.arange(len(exps))&#10;        width = 0.35&#10;        fig, ax = plt.subplots()&#10;        ax.axhline(0, color='black', linewidth=0.8)&#10;        ax.bar(x - width/2, vals_gt, width, label=paired_metrics[0])&#10;        ax.bar(x + width/2, vals_seg, width, label=paired_metrics[1])&#10;        ax.set_xticks(x)&#10;        ax.set_xticklabels(exps, rotation=45, ha='right')&#10;        ax.set_title(f&quot;GT vs Segmentation Segments for {dataset}&quot;)&#10;        ax.set_xlabel('Experiment')&#10;        ax.set_ylabel('Mean Number of Segments')&#10;        ax.legend()&#10;        plt.tight_layout()&#10;        fname = f&quot;{sanitize_filename(dataset)}_GT_vs_Segments.png&quot;&#10;        plt.savefig(os.path.join(outdir, fname))&#10;        plt.close()&#10;    print(f&quot;Combined segment plots saved in {outdir}&quot;)&#10;&#10;    # Combined bar charts for dimple center deviations&#10;    dimple_metrics = [&#10;        'Mean Dimples Center Left Deviation',&#10;        'Mean Dimples Center Right Deviation',&#10;        'Mean Dimples Center Left Deviation Abs',&#10;        'Mean Dimples Center Right Deviation Abs'&#10;    ]&#10;    for dataset in datasets:&#10;        exps = []&#10;        vals = {m: [] for m in dimple_metrics}&#10;        for exp, df in data.items():&#10;            row = df.loc[df['Dataset'] == dataset]&#10;            if not row.empty:&#10;                exps.append(exp)&#10;                for m in dimple_metrics:&#10;                    vals[m].append(row.iloc[0][m])&#10;        if not exps:&#10;            continue&#10;        # Sort experiments alphabetically&#10;        combined = sorted(zip(exps, *(vals[m] for m in dimple_metrics)), key=lambda x: x[0])&#10;        sorted_exps = [c[0] for c in combined]&#10;        sorted_vals = [list(c[i] for c in combined) for i in range(1, len(dimple_metrics)+1)]&#10;&#10;        x = np.arange(len(sorted_exps))&#10;        total_width = 0.8&#10;        width = total_width / len(dimple_metrics)&#10;        fig, ax = plt.subplots()&#10;        ax.axhline(0, color='black', linewidth=0.8)&#10;        for i, m in enumerate(dimple_metrics):&#10;            ax.bar(x - total_width/2 + width*i + width/2, sorted_vals[i], width, label=m)&#10;        ax.set_xticks(x)&#10;        ax.set_xticklabels(sorted_exps, rotation=45, ha='right')&#10;        ax.set_title(f&quot;Dimple Center Deviations for {dataset}&quot;)&#10;        ax.set_xlabel('Experiment')&#10;        ax.set_ylabel('Deviation')&#10;        ax.legend()&#10;        plt.tight_layout()&#10;        fname = f&quot;{sanitize_filename(dataset)}_dimple_deviation.png&quot;&#10;        plt.savefig(os.path.join(outdir, fname))&#10;        plt.close()&#10;    print(f&quot;Combined dimple deviation plots saved in {outdir}&quot;)&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>