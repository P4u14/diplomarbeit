<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SegmentationRunner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SegmentationRunner.py" />
              <option name="originalContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
              <option name="updatedContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/validation/aggregator.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/validation/aggregator.py" />
              <option name="originalContent" value="import numpy as np&#10;from collections import defaultdict&#10;from validation.evaluation_metrics import EvaluationMetrics&#10;&#10;&#10;def _safe_nanmean(arr):&#10;    if len(arr) == 0:&#10;        return None&#10;    return float(np.nanmean(arr))&#10;&#10;&#10;class MetricsAggregator:&#10;    &quot;&quot;&quot;Aggregate EvaluationMetrics into grouped means dynamically based on selected metrics.&quot;&quot;&quot;&#10;    def __init__(self, metric_names):&#10;        self.metric_names = metric_names&#10;        self.metrics_by_set = defaultdict(list)&#10;        self.metrics_by_sick = {'Sick': [], 'Healthy': []}&#10;        self.all_metrics = []&#10;&#10;    def add(self, dataset: str, sick: float, metrics: EvaluationMetrics):&#10;        self.metrics_by_set[dataset].append(metrics)&#10;        if sick == 1.0:&#10;            self.metrics_by_sick['Sick'].append(metrics)&#10;        elif sick == 0.0:&#10;            self.metrics_by_sick['Healthy'].append(metrics)&#10;        self.all_metrics.append(metrics)&#10;&#10;    def compute_means(self):&#10;        &quot;&quot;&quot;Return list of rows for mean CSV: per dataset, Sick, Healthy, All Datasets&quot;&quot;&quot;&#10;        rows = []&#10;        # per-dataset&#10;        for ds, mlist in self.metrics_by_set.items():&#10;            rows.append(self._make_row(ds, mlist))&#10;        # Sick and Healthy&#10;        for status in ['Sick', 'Healthy']:&#10;            rows.append(self._make_row(status, self.metrics_by_sick.get(status, [])))&#10;        # overall&#10;        rows.append(self._make_row('All Datasets', self.all_metrics))&#10;        return rows&#10;&#10;    def _make_row(self, label, mlist):&#10;        # compute mean per selected metric&#10;        row = [label]&#10;        for name in self.metric_names:&#10;            vals = [getattr(m, name) for m in mlist if getattr(m, name) is not None]&#10;            mean = float(np.nanmean(vals)) if vals else None&#10;            row.append(mean)&#10;        return row" />
              <option name="updatedContent" value="import numpy as np&#10;from collections import defaultdict&#10;from validation.evaluation_metrics import EvaluationMetrics&#10;&#10;&#10;def _safe_nanmean(arr):&#10;    if len(arr) == 0:&#10;        return None&#10;    return float(np.nanmean(arr))&#10;&#10;&#10;class MetricsAggregator:&#10;    &quot;&quot;&quot;Aggregate EvaluationMetrics into grouped means dynamically based on selected metrics.&quot;&quot;&quot;&#10;    def __init__(self, metric_names):&#10;        self.metric_names = metric_names&#10;        self.metrics_by_set = defaultdict(list)&#10;        self.metrics_by_sick = {'Sick': [], 'Healthy': []}&#10;        self.all_metrics = []&#10;&#10;    def add(self, dataset: str, sick: float, metrics: EvaluationMetrics):&#10;        self.metrics_by_set[dataset].append(metrics)&#10;        if sick == 1.0:&#10;            self.metrics_by_sick['Sick'].append(metrics)&#10;        elif sick == 0.0:&#10;            self.metrics_by_sick['Healthy'].append(metrics)&#10;        self.all_metrics.append(metrics)&#10;&#10;    def compute_means(self):&#10;        &quot;&quot;&quot;Return list of rows for mean CSV: per dataset, Sick, Healthy, All Datasets&quot;&quot;&quot;&#10;        rows = []&#10;        # per-dataset&#10;        for ds, mlist in self.metrics_by_set.items():&#10;            rows.append(self._make_row(ds, mlist))&#10;        # Sick and Healthy&#10;        for status in ['Sick', 'Healthy']:&#10;            rows.append(self._make_row(status, self.metrics_by_sick.get(status, [])))&#10;        # overall&#10;        rows.append(self._make_row('All Datasets', self.all_metrics))&#10;        return rows&#10;&#10;    def _make_row(self, label, mlist):&#10;        # compute mean per selected metric&#10;        row = [label]&#10;        for name in self.metric_names:&#10;            vals = [getattr(m, name) for m in mlist if getattr(m, name) is not None]&#10;            mean = float(np.nanmean(vals)) if vals else None&#10;            row.append(mean)&#10;        return row" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualization/bar_plotter.csv.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualization/bar_plotter.csv.py" />
              <option name="originalContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BarPlotter(Plotter):&#10;    def __init__(self, columns):&#10;        self.columns = columns&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            values = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    # Use explicit value from the 'All Datasets' row instead of column mean&#10;                    if 'All Datasets' in df.index:&#10;                        values.append(df.loc['All Datasets', col])&#10;                    else:&#10;                        raise ValueError(f&quot;Row 'All Datasets' not found in DataFrame for experiment.&quot;)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.bar(exp_names, values)&#10;            plt.title(f&quot;{col} across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;            out_path = os.path.join(output_dir, f&quot;{col}_bar_chart.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved bar chart for '{col}' to {out_path}&quot;)" />
              <option name="updatedContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BarPlotter(Plotter):&#10;    def __init__(self, columns):&#10;        self.columns = columns&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            values = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    # Use explicit value from the 'All Datasets' row instead of column mean&#10;                    if 'All Datasets' in df.index:&#10;                        values.append(df.loc['All Datasets', col])&#10;                    else:&#10;                        raise ValueError(f&quot;Row 'All Datasets' not found in DataFrame for experiment.&quot;)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.bar(exp_names, values)&#10;            plt.title(f&quot;{col} across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;            out_path = os.path.join(output_dir, f&quot;{col}_bar_chart.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved bar chart for '{col}' to {out_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>