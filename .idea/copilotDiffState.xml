<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SegmentationRunner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SegmentationRunner.py" />
              <option name="originalContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
              <option name="updatedContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fuse_results.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fuse_results.py" />
              <option name="originalContent" value="import os&#10;from PIL import Image, ImageDraw&#10;import numpy as np&#10;from tqdm import tqdm&#10;&#10;# Konfiguration&#10;results_to_fuse = [&#10;    &quot;data/Atlas_Experiment01&quot;,&#10;    # weitere Ordner nach Bedarf&#10;]&#10;GT_PATH = &quot;data/Validation_Data_Small&quot;&#10;OUTPUT_DIR = &quot;data/Fused_Results/&quot;&#10;&#10;# Farben für die Umrandung&#10;PINK = (255, 105, 180, 255 )   # Helleres Neon-Pink&#10;ORANGE = (255, 165, 0, 255)   # Helleres Neon-Orange&#10;&#10;&#10;def find_contours(mask_arr, thickness=1):&#10;    from scipy.ndimage import binary_dilation&#10;    mask = mask_arr &gt; 0&#10;    dilated = mask.copy()&#10;    for _ in range(thickness):&#10;        dilated = binary_dilation(dilated)&#10;    contour = np.logical_and(dilated, ~mask)&#10;    return contour&#10;&#10;def overlay_contour(base_img, mask_img, color, thickness=3):&#10;    mask_arr = np.array(mask_img.convert(&quot;L&quot;))&#10;    contour = find_contours(mask_arr, thickness=thickness)&#10;    overlay = Image.new(&quot;RGBA&quot;, base_img.size, (0,0,0,0))&#10;    draw = ImageDraw.Draw(overlay)&#10;    ys, xs = np.where(contour)&#10;    for x, y in zip(xs, ys):&#10;        draw.point((x, y), fill=color)&#10;    return Image.alpha_composite(base_img.convert(&quot;RGBA&quot;), overlay)&#10;&#10;def process_image(img_name, fuse_dir, gt_path, output_dir):&#10;    # Masks&#10;    seg_mask_path = os.path.join(fuse_dir, img_name)&#10;    gt_mask_path = os.path.join(gt_path, img_name)&#10;&#10;    # Original image&#10;    orig_path = os.path.join(gt_path, img_name.replace('-mask.Gauss.png', '.Gauss.png'))&#10;    if not os.path.exists(orig_path):&#10;        print('Original image not found for', img_name)&#10;        return&#10;&#10;    base_img = Image.open(orig_path)&#10;&#10;    result = base_img.copy()&#10;    if os.path.exists(seg_mask_path):&#10;        seg_mask = Image.open(seg_mask_path)&#10;        result = overlay_contour(result, seg_mask, ORANGE, thickness=3)&#10;    if os.path.exists(gt_mask_path):&#10;        gt_mask = Image.open(gt_mask_path)&#10;        result = overlay_contour(result, gt_mask, PINK, thickness=3)&#10;    out_path = os.path.join(output_dir, img_name)&#10;    result.save(out_path)&#10;&#10;def main():&#10;    for fuse_dir in results_to_fuse:&#10;        output_path = OUTPUT_DIR +&quot;/&quot; + os.path.basename(fuse_dir)&#10;        os.makedirs(output_path, exist_ok=True)&#10;        for img_name in tqdm(os.listdir(fuse_dir), desc='Preprocessing image for ' + os.path.basename(fuse_dir)):&#10;            if not img_name.endswith('.png') or '-mask' not in img_name:&#10;                continue&#10;            process_image(img_name, fuse_dir, GT_PATH, output_path)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import os&#10;from PIL import Image, ImageDraw&#10;import numpy as np&#10;from tqdm import tqdm&#10;&#10;# Konfiguration&#10;results_to_fuse = [&#10;    &quot;data/Atlas_Experiment01&quot;,&#10;    # weitere Ordner nach Bedarf&#10;]&#10;GT_PATH = &quot;data/Validation_Data_Small&quot;&#10;OUTPUT_DIR = &quot;data/Fused_Results/&quot;&#10;&#10;# Farben für die Umrandung&#10;PINK = (255, 105, 180, 255 )   # Helleres Neon-Pink&#10;ORANGE = (255, 165, 0, 255)   # Helleres Neon-Orange&#10;&#10;&#10;def find_contours(mask_arr, thickness=1):&#10;    from scipy.ndimage import binary_dilation&#10;    mask = mask_arr &gt; 0&#10;    dilated = mask.copy()&#10;    for _ in range(thickness):&#10;        dilated = binary_dilation(dilated)&#10;    contour = np.logical_and(dilated, ~mask)&#10;    return contour&#10;&#10;def overlay_contour(base_img, mask_img, color, thickness=3):&#10;    mask_arr = np.array(mask_img.convert(&quot;L&quot;))&#10;    contour = find_contours(mask_arr, thickness=thickness)&#10;    overlay = Image.new(&quot;RGBA&quot;, base_img.size, (0,0,0,0))&#10;    draw = ImageDraw.Draw(overlay)&#10;    ys, xs = np.where(contour)&#10;    for x, y in zip(xs, ys):&#10;        draw.point((x, y), fill=color)&#10;    return Image.alpha_composite(base_img.convert(&quot;RGBA&quot;), overlay)&#10;&#10;def process_image(img_name, fuse_dir, gt_path, output_dir):&#10;    # Masks&#10;    seg_mask_path = os.path.join(fuse_dir, img_name)&#10;    gt_mask_path = os.path.join(gt_path, img_name)&#10;&#10;    # Original image&#10;    orig_path = os.path.join(gt_path, img_name.replace('-mask.Gauss.png', '.Gauss.png'))&#10;    if not os.path.exists(orig_path):&#10;        print('Original image not found for', img_name)&#10;        return&#10;&#10;    base_img = Image.open(orig_path)&#10;&#10;    result = base_img.copy()&#10;    if os.path.exists(seg_mask_path):&#10;        seg_mask = Image.open(seg_mask_path)&#10;        result = overlay_contour(result, seg_mask, ORANGE, thickness=3)&#10;    if os.path.exists(gt_mask_path):&#10;        gt_mask = Image.open(gt_mask_path)&#10;        result = overlay_contour(result, gt_mask, PINK, thickness=3)&#10;    out_path = os.path.join(output_dir, img_name)&#10;    result.save(out_path)&#10;&#10;def main():&#10;    for fuse_dir in results_to_fuse:&#10;        output_path = OUTPUT_DIR +&quot;/&quot; + os.path.basename(fuse_dir)&#10;        os.makedirs(output_path, exist_ok=True)&#10;        for img_name in tqdm(os.listdir(fuse_dir), desc='Preprocessing image for ' + os.path.basename(fuse_dir)):&#10;            if not img_name.endswith('.png') or '-mask' not in img_name:&#10;                continue&#10;            process_image(img_name, fuse_dir, GT_PATH, output_path)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>