<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SegmentationRunner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SegmentationRunner.py" />
              <option name="originalContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
              <option name="updatedContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualization/bar_plotter.csv.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualization/bar_plotter.csv.py" />
              <option name="originalContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BarPlotter(Plotter):&#10;    def __init__(self, columns):&#10;        self.columns = columns&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            values = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    # Use explicit value from the 'All Datasets' row instead of column mean&#10;                    if 'All Datasets' in df.index:&#10;                        values.append(df.loc['All Datasets', col])&#10;                    else:&#10;                        raise ValueError(f&quot;Row 'All Datasets' not found in DataFrame for experiment.&quot;)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.bar(exp_names, values)&#10;            plt.title(f&quot;{col} across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;            out_path = os.path.join(output_dir, f&quot;{col}_bar_chart.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved bar chart for '{col}' to {out_path}&quot;)" />
              <option name="updatedContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BarPlotter(Plotter):&#10;    def __init__(self, columns):&#10;        self.columns = columns&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            values = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    # Use explicit value from the 'All Datasets' row instead of column mean&#10;                    if 'All Datasets' in df.index:&#10;                        values.append(df.loc['All Datasets', col])&#10;                    else:&#10;                        raise ValueError(f&quot;Row 'All Datasets' not found in DataFrame for experiment.&quot;)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.bar(exp_names, values)&#10;            plt.title(f&quot;{col} across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;            out_path = os.path.join(output_dir, f&quot;{col}_bar_chart.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved bar chart for '{col}' to {out_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualization/bar_plotter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualization/bar_plotter.py" />
              <option name="originalContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BarPlotter(Plotter):&#10;    def __init__(self, columns, directory='bar_charts'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            values = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    # Select value from row where 'Dataset' column equals 'All Datasets'&#10;                    if 'Dataset' in df.columns and 'All Datasets' in df['Dataset'].values:&#10;                        row = df.loc[df['Dataset'] == 'All Datasets']&#10;                        values.append(row.iloc[0][col])&#10;                    else:&#10;                        raise ValueError(&quot;No row with 'Dataset' == 'All Datasets' found in DataFrame.&quot;)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.bar(exp_names, values)&#10;            plt.title(f&quot;{col} across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.ylim(bottom=0)&#10;            plt.tight_layout()&#10;            # Create bar_charts directory if it doesn't exist&#10;            dir_path = os.path.join(output_dir, self.directory)&#10;            os.makedirs(dir_path, exist_ok=True)&#10;            # Replace spaces in column name for filename&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            out_path = os.path.join(dir_path, f&quot;{safe_col}_bar_chart.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved bar chart for '{col}' to {out_path}&quot;)" />
              <option name="updatedContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BarPlotter(Plotter):&#10;    def __init__(self, columns, directory='bar_charts'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            values = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    # Select value from row where 'Dataset' column equals 'All Datasets'&#10;                    if 'Dataset' in df.columns and 'All Datasets' in df['Dataset'].values:&#10;                        row = df.loc[df['Dataset'] == 'All Datasets']&#10;                        values.append(row.iloc[0][col])&#10;                    else:&#10;                        raise ValueError(&quot;No row with 'Dataset' == 'All Datasets' found in DataFrame.&quot;)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.bar(exp_names, values)&#10;            plt.title(f&quot;{col} across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.ylim(bottom=0)&#10;            plt.tight_layout()&#10;            # Create bar_charts directory if it doesn't exist&#10;            dir_path = os.path.join(output_dir, self.directory)&#10;            os.makedirs(dir_path, exist_ok=True)&#10;            # Replace spaces in column name for filename&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            out_path = os.path.join(dir_path, f&quot;{safe_col}_bar_chart.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved bar chart for '{col}' to {out_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualization/box_plotter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualization/box_plotter.py" />
              <option name="originalContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BoxPlotter(Plotter):&#10;    def __init__(self, columns, directory='box_plots'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            data = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    data.append(df[col].dropna().values)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.boxplot(data, labels=exp_names)&#10;            plt.title(f&quot;{col} distribution across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;            plt.ylim(bottom=0)&#10;            # ensure output subdirectory exists&#10;            dir_path = os.path.join(output_dir, self.directory)&#10;            os.makedirs(dir_path, exist_ok=True)&#10;            # sanitize column name for filename&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            out_path = os.path.join(dir_path, f&quot;{safe_col}_box_plot.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved box plot for '{col}' to {out_path}&quot;)" />
              <option name="updatedContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class BoxPlotter(Plotter):&#10;    def __init__(self, columns, directory='box_plots'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            data = []&#10;            for df in dfs:&#10;                if col in df.columns:&#10;                    data.append(df[col].dropna().values)&#10;                else:&#10;                    raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;            plt.figure()&#10;            plt.boxplot(data, labels=exp_names)&#10;            plt.title(f&quot;{col} distribution across experiments&quot;)&#10;            plt.ylabel(col)&#10;            plt.xticks(rotation=45, ha='right')&#10;            plt.tight_layout()&#10;            plt.ylim(bottom=0)&#10;            # ensure output subdirectory exists&#10;            dir_path = os.path.join(output_dir, self.directory)&#10;            os.makedirs(dir_path, exist_ok=True)&#10;            # sanitize column name for filename&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            out_path = os.path.join(dir_path, f&quot;{safe_col}_box_plot.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved box plot for '{col}' to {out_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualization/heatmap_plotter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualization/heatmap_plotter.py" />
              <option name="originalContent" value="import os&#10;import pandas as pd&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class HeatmapPlotter(Plotter):&#10;    def __init__(self, columns, directory='heatmap_plots', cmap='viridis'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;        self.cmap = cmap&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        import numpy as np&#10;        # Ensure DataFrame column names have no extra whitespace&#10;        for df in dfs:&#10;            df.columns = df.columns.str.strip()&#10;        # Convert all metric columns to numeric, coercing errors to NaN&#10;        for df in dfs:&#10;            for col in self.columns:&#10;                if col in df.columns:&#10;                    df[col] = df[col].apply(pd.to_numeric, errors='coerce')&#10;        # Collect file names and dataset labels from first DataFrame (exclude aggregate 'All Datasets')&#10;        df0 = dfs[0]&#10;        print(&quot;Debug: columns in first DataFrame:&quot;, df0.columns.tolist())&#10;        if 'Dataset' not in df0.columns or 'File Name' not in df0.columns:&#10;            raise ValueError(&quot;Columns 'Dataset' or 'File Name' not found in DataFrame.&quot;)&#10;        # determine valid entries excluding aggregate&#10;        mask = df0['Dataset'] != 'All Datasets'&#10;        # determine unique datasets sorted alphabetically&#10;        unique_datasets = sorted(df0.loc[mask, 'Dataset'].unique())&#10;        # build file list grouped by dataset and health status&#10;        file_names = []&#10;        dataset_labels = []&#10;        status_labels = []&#10;        # convert Sick column to numeric&#10;        df0['Sick'] = pd.to_numeric(df0['Sick'], errors='coerce')&#10;        for d in unique_datasets:&#10;            df_d = df0[mask &amp; (df0['Dataset'] == d)]&#10;            # healthy if Sick is 0 or -1&#10;            healthy = sorted(df_d.loc[df_d['Sick'].isin([0, -1]), 'File Name'].tolist())&#10;            sick = sorted(df_d.loc[~df_d['Sick'].isin([0, -1]), 'File Name'].tolist())&#10;            for fn in healthy:&#10;                file_names.append(fn); dataset_labels.append(d); status_labels.append('Healthy')&#10;            for fn in sick:&#10;                file_names.append(fn); dataset_labels.append(d); status_labels.append('Sick')&#10;        # ensure output directory exists&#10;        dir_path = os.path.join(output_dir, self.directory)&#10;        os.makedirs(dir_path, exist_ok=True)&#10;        # Plot heatmap for each metric&#10;        for col in self.columns:&#10;            # build matrix: rows=files, cols=experiments&#10;            matrix = []&#10;            for fname in file_names:&#10;                row_vals = []&#10;                for df in dfs:&#10;                    if col not in df.columns or 'File Name' not in df.columns:&#10;                        raise ValueError(f&quot;Columns 'File Name' or '{col}' not found in DataFrame for experiment.&quot;)&#10;                    # find row for this file name&#10;                    row = df.loc[df['File Name'] == fname]&#10;                    if row.empty:&#10;                        raise ValueError(f&quot;File '{fname}' not found in DataFrame for experiment.&quot;)&#10;                    row_vals.append(row.iloc[0][col])&#10;                matrix.append(row_vals)&#10;            matrix = np.array(matrix)&#10;            # produce heatmap with auto-scaled color range&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            plt.figure()&#10;            # mask missing values and set mask color to black&#10;            m = np.ma.masked_invalid(matrix)&#10;            cmap = plt.get_cmap(self.cmap).copy()&#10;            cmap.set_bad(color='black')&#10;            # auto-scale color to valid data range&#10;            auto_vmin = np.nanmin(matrix)&#10;            auto_vmax = np.nanmax(matrix)&#10;            im = plt.imshow(m, cmap=cmap, aspect='auto', interpolation='nearest', vmin=auto_vmin, vmax=auto_vmax)&#10;            ax = plt.gca()&#10;            # set major ticks for experiment labels&#10;            ax.set_xticks(range(len(exp_names)))&#10;            # draw white vertical separators between experiments&#10;            for i in range(len(exp_names) - 1):&#10;                ax.axvline(i + 0.5, color='w', linewidth=2)&#10;            # compute separators and y-ticks grouping by health&#10;            status_boundaries = []&#10;            dataset_boundaries = []&#10;            positions = []&#10;            labels = []&#10;            for d in unique_datasets:&#10;                # indices for this dataset block&#10;                idxs = [i for i, dl in enumerate(dataset_labels) if dl == d]&#10;                healthy_idxs = [i for i in idxs if status_labels[i] == 'Healthy']&#10;                sick_idxs = [i for i in idxs if status_labels[i] == 'Sick']&#10;                # separator between healthy and sick rows&#10;                if healthy_idxs and sick_idxs:&#10;                    status_boundaries.append(healthy_idxs[-1] + 0.5)&#10;                # separator after entire dataset block&#10;                dataset_boundaries.append(idxs[-1] + 0.5)&#10;                # tick label positions and labels&#10;                if healthy_idxs:&#10;                    positions.append((healthy_idxs[0] + healthy_idxs[-1]) / 2)&#10;                    labels.append(f&quot;{d} Healthy&quot;)&#10;                if sick_idxs:&#10;                    positions.append((sick_idxs[0] + sick_idxs[-1]) / 2)&#10;                    labels.append(f&quot;{d} Sick&quot;)&#10;            # draw horizontal separators: health status and dataset boundaries&#10;            for b in status_boundaries:&#10;                ax.axhline(b, color='w', linewidth=7)&#10;            for b in dataset_boundaries:&#10;                ax.axhline(b, color='w', linewidth=10)&#10;            plt.colorbar(im)&#10;            plt.xticks(range(len(exp_names)), exp_names, rotation=45, ha='right')&#10;            # set y-axis ticks for status subgroups&#10;            plt.yticks(positions, labels)&#10;            plt.title(f&quot;{col} across experiments per file (auto-scaled)&quot;)&#10;            plt.tight_layout()&#10;            out_path = os.path.join(dir_path, f&quot;{safe_col}_heatmap.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved heatmap for '{col}' to {out_path}&quot;)&#10;" />
              <option name="updatedContent" value="import os&#10;import pandas as pd&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class HeatmapPlotter(Plotter):&#10;    def __init__(self, columns, directory='heatmap_plots', cmap='viridis'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;        self.cmap = cmap&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        import numpy as np&#10;        # Ensure DataFrame column names have no extra whitespace&#10;        for df in dfs:&#10;            df.columns = df.columns.str.strip()&#10;        # Convert all metric columns to numeric, coercing errors to NaN&#10;        for df in dfs:&#10;            for col in self.columns:&#10;                if col in df.columns:&#10;                    df[col] = df[col].apply(pd.to_numeric, errors='coerce')&#10;        # Collect file names and dataset labels from first DataFrame (exclude aggregate 'All Datasets')&#10;        df0 = dfs[0]&#10;        print(&quot;Debug: columns in first DataFrame:&quot;, df0.columns.tolist())&#10;        if 'Dataset' not in df0.columns or 'File Name' not in df0.columns:&#10;            raise ValueError(&quot;Columns 'Dataset' or 'File Name' not found in DataFrame.&quot;)&#10;        # determine valid entries excluding aggregate&#10;        mask = df0['Dataset'] != 'All Datasets'&#10;        # determine unique datasets sorted alphabetically&#10;        unique_datasets = sorted(df0.loc[mask, 'Dataset'].unique())&#10;        # build file list grouped by dataset and health status&#10;        file_names = []&#10;        dataset_labels = []&#10;        status_labels = []&#10;        # convert Sick column to numeric&#10;        df0['Sick'] = pd.to_numeric(df0['Sick'], errors='coerce')&#10;        for d in unique_datasets:&#10;            df_d = df0[mask &amp; (df0['Dataset'] == d)]&#10;            # healthy if Sick is 0 or -1&#10;            healthy = sorted(df_d.loc[df_d['Sick'].isin([0, -1]), 'File Name'].tolist())&#10;            sick = sorted(df_d.loc[~df_d['Sick'].isin([0, -1]), 'File Name'].tolist())&#10;            for fn in healthy:&#10;                file_names.append(fn); dataset_labels.append(d); status_labels.append('Healthy')&#10;            for fn in sick:&#10;                file_names.append(fn); dataset_labels.append(d); status_labels.append('Sick')&#10;        # ensure output directory exists&#10;        dir_path = os.path.join(output_dir, self.directory)&#10;        os.makedirs(dir_path, exist_ok=True)&#10;        # Plot heatmap for each metric&#10;        for col in self.columns:&#10;            # build matrix: rows=files, cols=experiments&#10;            matrix = []&#10;            for fname in file_names:&#10;                row_vals = []&#10;                for df in dfs:&#10;                    if col not in df.columns or 'File Name' not in df.columns:&#10;                        raise ValueError(f&quot;Columns 'File Name' or '{col}' not found in DataFrame for experiment.&quot;)&#10;                    # find row for this file name&#10;                    row = df.loc[df['File Name'] == fname]&#10;                    if row.empty:&#10;                        raise ValueError(f&quot;File '{fname}' not found in DataFrame for experiment.&quot;)&#10;                    row_vals.append(row.iloc[0][col])&#10;                matrix.append(row_vals)&#10;            matrix = np.array(matrix)&#10;            # produce heatmap with auto-scaled color range&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            plt.figure()&#10;            # mask missing values and set mask color to black&#10;            m = np.ma.masked_invalid(matrix)&#10;            cmap = plt.get_cmap(self.cmap).copy()&#10;            cmap.set_bad(color='black')&#10;            # auto-scale color to valid data range&#10;            auto_vmin = np.nanmin(matrix)&#10;            auto_vmax = np.nanmax(matrix)&#10;            im = plt.imshow(m, cmap=cmap, aspect='auto', interpolation='nearest', vmin=auto_vmin, vmax=auto_vmax)&#10;            ax = plt.gca()&#10;            # set major ticks for experiment labels&#10;            ax.set_xticks(range(len(exp_names)))&#10;            # draw white vertical separators between experiments&#10;            for i in range(len(exp_names) - 1):&#10;                ax.axvline(i + 0.5, color='w', linewidth=2)&#10;            # compute separators and y-ticks grouping by health&#10;            status_boundaries = []&#10;            dataset_boundaries = []&#10;            positions = []&#10;            labels = []&#10;            for d in unique_datasets:&#10;                # indices for this dataset block&#10;                idxs = [i for i, dl in enumerate(dataset_labels) if dl == d]&#10;                healthy_idxs = [i for i in idxs if status_labels[i] == 'Healthy']&#10;                sick_idxs = [i for i in idxs if status_labels[i] == 'Sick']&#10;                # separator between healthy and sick rows&#10;                if healthy_idxs and sick_idxs:&#10;                    status_boundaries.append(healthy_idxs[-1] + 0.5)&#10;                # separator after entire dataset block&#10;                dataset_boundaries.append(idxs[-1] + 0.5)&#10;                # tick label positions and labels&#10;                if healthy_idxs:&#10;                    positions.append((healthy_idxs[0] + healthy_idxs[-1]) / 2)&#10;                    labels.append(f&quot;{d} Healthy&quot;)&#10;                if sick_idxs:&#10;                    positions.append((sick_idxs[0] + sick_idxs[-1]) / 2)&#10;                    labels.append(f&quot;{d} Sick&quot;)&#10;            # draw horizontal separators: health status and dataset boundaries&#10;            for b in status_boundaries:&#10;                ax.axhline(b, color='w', linewidth=7)&#10;            for b in dataset_boundaries:&#10;                ax.axhline(b, color='w', linewidth=10)&#10;            plt.colorbar(im)&#10;            plt.xticks(range(len(exp_names)), exp_names, rotation=45, ha='right')&#10;            # set y-axis ticks for status subgroups&#10;            plt.yticks(positions, labels)&#10;            plt.title(f&quot;{col} across experiments per file (auto-scaled)&quot;)&#10;            plt.tight_layout()&#10;            out_path = os.path.join(dir_path, f&quot;{safe_col}_heatmap.png&quot;)&#10;            plt.savefig(out_path)&#10;            plt.close()&#10;            print(f&quot;Saved heatmap for '{col}' to {out_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualization/line_plotter.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualization/line_plotter.py" />
              <option name="originalContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class LinePlotter(Plotter):&#10;    def __init__(self, columns, directory='line_plots'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            # Define groups of Dataset categories to plot&#10;            groups = {&#10;                'datasets': ['wip', 'mBrace', 'gkge', 'skolioseKielce', 'All Datasets'],&#10;                'health': ['Sick', 'Healthy', 'All Datasets'],&#10;            }&#10;            # ensure output subdirectory exists&#10;            dir_path = os.path.join(output_dir, self.directory)&#10;            os.makedirs(dir_path, exist_ok=True)&#10;            # sanitize column name for filenames&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            # Generate line plot for each group&#10;            for group_name, items in groups.items():&#10;                plt.figure()&#10;                for item in items:&#10;                    series = []&#10;                    for df in dfs:&#10;                        if col not in df.columns:&#10;                            raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;                        if 'Dataset' not in df.columns or item not in df['Dataset'].values:&#10;                            raise ValueError(f&quot;No row with 'Dataset' == '{item}' found in DataFrame.&quot;)&#10;                        row = df.loc[df['Dataset'] == item]&#10;                        series.append(row.iloc[0][col])&#10;                    plt.plot(exp_names, series, marker='o', label=item)&#10;                plt.title(f&quot;{col} trend across experiments ({group_name})&quot;)&#10;                plt.ylabel(col)&#10;                plt.xticks(rotation=45, ha='right')&#10;                plt.legend()&#10;                plt.ylim(bottom=0)&#10;                plt.tight_layout()&#10;                safe_group = group_name.replace(&quot; &quot;, &quot;_&quot;)&#10;                out_path = os.path.join(dir_path, f&quot;{safe_col}_{safe_group}_line_plot.png&quot;)&#10;                plt.savefig(out_path)&#10;                plt.close()&#10;                print(f&quot;Saved {group_name} line plot for '{col}' to {out_path}&quot;)&#10;" />
              <option name="updatedContent" value="import os&#10;&#10;from matplotlib import pyplot as plt&#10;&#10;from visualization.plotter import Plotter&#10;&#10;&#10;class LinePlotter(Plotter):&#10;    def __init__(self, columns, directory='line_plots'):&#10;        self.columns = columns&#10;        self.directory = directory&#10;&#10;    def plot(self, dfs, exp_names, output_dir):&#10;        for col in self.columns:&#10;            # Define groups of Dataset categories to plot&#10;            groups = {&#10;                'datasets': ['wip', 'mBrace', 'gkge', 'skolioseKielce', 'All Datasets'],&#10;                'health': ['Sick', 'Healthy', 'All Datasets'],&#10;            }&#10;            # ensure output subdirectory exists&#10;            dir_path = os.path.join(output_dir, self.directory)&#10;            os.makedirs(dir_path, exist_ok=True)&#10;            # sanitize column name for filenames&#10;            safe_col = col.replace(&quot; &quot;, &quot;_&quot;)&#10;            # Generate line plot for each group&#10;            for group_name, items in groups.items():&#10;                plt.figure()&#10;                for item in items:&#10;                    series = []&#10;                    for df in dfs:&#10;                        if col not in df.columns:&#10;                            raise ValueError(f&quot;Column '{col}' not found in DataFrame for experiment.&quot;)&#10;                        if 'Dataset' not in df.columns or item not in df['Dataset'].values:&#10;                            raise ValueError(f&quot;No row with 'Dataset' == '{item}' found in DataFrame.&quot;)&#10;                        row = df.loc[df['Dataset'] == item]&#10;                        series.append(row.iloc[0][col])&#10;                    plt.plot(exp_names, series, marker='o', label=item)&#10;                plt.title(f&quot;{col} trend across experiments ({group_name})&quot;)&#10;                plt.ylabel(col)&#10;                plt.xticks(rotation=45, ha='right')&#10;                plt.legend()&#10;                plt.ylim(bottom=0)&#10;                plt.tight_layout()&#10;                safe_group = group_name.replace(&quot; &quot;, &quot;_&quot;)&#10;                out_path = os.path.join(dir_path, f&quot;{safe_col}_{safe_group}_line_plot.png&quot;)&#10;                plt.savefig(out_path)&#10;                plt.close()&#10;                print(f&quot;Saved {group_name} line plot for '{col}' to {out_path}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/visualize.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/visualize.py" />
              <option name="originalContent" value="import os&#10;from pandas import read_csv&#10;&#10;from visualization.bar_plotter import BarPlotter&#10;from visualization.box_plotter import BoxPlotter&#10;from visualization.line_plotter import LinePlotter&#10;from visualization.heatmap_plotter import HeatmapPlotter&#10;&#10;# --- Configuration: define base path, experiment names and output dir here ---&#10;BASE_VALIDATION_PATH = 'data/Results/Validation'&#10;EXPERIMENTS = [&#10;    # Experiment identifiers (without suffix)&#10;    'Atlas_Experiment01',&#10;    'Atlas_Experiment02',&#10;    'Atlas_Experiment03',&#10;    # add more experiments here...&#10;]&#10;COLUMNS = [&#10;    # Column names to plot&#10;    'Dice', 'Precision', 'Recall'&#10;]&#10;OUTPUT_DIR = 'data/Results/Plots/'&#10;# Define plotter instances to use&#10;PLOTTERS = [&#10;    BarPlotter(COLUMNS),&#10;    BoxPlotter(COLUMNS),&#10;    LinePlotter(COLUMNS),&#10;    HeatmapPlotter(COLUMNS)&#10;]&#10;# ---------------------------------------------------------------&#10;&#10;&#10;class Visualizer:&#10;    def __init__(self, csv_paths, plotters, output_dir):&#10;        self.experiment_names = csv_paths&#10;        self.plotters = plotters&#10;        self.output_dir = output_dir&#10;&#10;    def run(self):&#10;        os.makedirs(self.output_dir, exist_ok=True)&#10;        # Plot each plotter: build file paths from base path and experiment names&#10;        for plotter in self.plotters:&#10;            # choose suffix based on plotter type&#10;            if isinstance(plotter, (BoxPlotter, HeatmapPlotter)):&#10;                suffix = '_all.csv'&#10;            else:&#10;                suffix = '_mean.csv'&#10;            # assemble file paths&#10;            paths = [os.path.join(BASE_VALIDATION_PATH, name + suffix) for name in self.experiment_names]&#10;            dfs = [read_csv(p) for p in paths]&#10;            # use experiment_names as labels&#10;            plotter.plot(dfs, self.experiment_names, self.output_dir)&#10;&#10;&#10;def main():&#10;    # Instantiate and run Visualizer with configuration above&#10;    viz = Visualizer(EXPERIMENTS, PLOTTERS, OUTPUT_DIR)&#10;    viz.run()&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
              <option name="updatedContent" value="import os&#10;from pandas import read_csv&#10;&#10;from visualization.bar_plotter import BarPlotter&#10;from visualization.box_plotter import BoxPlotter&#10;from visualization.line_plotter import LinePlotter&#10;from visualization.heatmap_plotter import HeatmapPlotter&#10;&#10;# --- Configuration: define base path, experiment names and output dir here ---&#10;BASE_VALIDATION_PATH = 'data/Results/Validation'&#10;EXPERIMENTS = [&#10;    # Experiment identifiers (without suffix)&#10;    'Atlas_Experiment01',&#10;    'Atlas_Experiment02',&#10;    'Atlas_Experiment03',&#10;    # add more experiments here...&#10;]&#10;COLUMNS = [&#10;    # Column names to plot&#10;    'Dice', 'Precision', 'Recall'&#10;]&#10;OUTPUT_DIR = 'data/Results/Plots/'&#10;# Define plotter instances to use&#10;PLOTTERS = [&#10;    BarPlotter(COLUMNS),&#10;    BoxPlotter(COLUMNS),&#10;    LinePlotter(COLUMNS),&#10;    HeatmapPlotter(COLUMNS)&#10;]&#10;# ---------------------------------------------------------------&#10;&#10;&#10;class Visualizer:&#10;    def __init__(self, csv_paths, plotters, output_dir):&#10;        self.experiment_names = csv_paths&#10;        self.plotters = plotters&#10;        self.output_dir = output_dir&#10;&#10;    def run(self):&#10;        os.makedirs(self.output_dir, exist_ok=True)&#10;        # Plot each plotter: build file paths from base path and experiment names&#10;        for plotter in self.plotters:&#10;            # choose suffix based on plotter type&#10;            if isinstance(plotter, (BoxPlotter, HeatmapPlotter)):&#10;                suffix = '_all.csv'&#10;            else:&#10;                suffix = '_mean.csv'&#10;            # assemble file paths&#10;            paths = [os.path.join(BASE_VALIDATION_PATH, name + suffix) for name in self.experiment_names]&#10;            dfs = [read_csv(p) for p in paths]&#10;            # use experiment_names as labels&#10;            plotter.plot(dfs, self.experiment_names, self.output_dir)&#10;&#10;&#10;def main():&#10;    # Instantiate and run Visualizer with configuration above&#10;    viz = Visualizer(EXPERIMENTS, PLOTTERS, OUTPUT_DIR)&#10;    viz.run()&#10;&#10;&#10;if __name__ == '__main__':&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>