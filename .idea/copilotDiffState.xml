<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/preprocessing/torso_roi_preprocessor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/preprocessing/torso_roi_preprocessor.py" />
              <option name="originalContent" value="import numpy as np&#10;from skimage.transform import resize&#10;import matplotlib.pyplot as plt&#10;&#10;from preprocessing.preprocessing_step import IPreprocessingStep&#10;&#10;&#10;def show_image(image, title=&quot;&quot;):&#10;    &quot;&quot;&quot;Helper function to display an image.&quot;&quot;&quot;&#10;    display_image = (image * 255).astype(np.uint8)&#10;    if image.ndim == 2:&#10;        plt.imshow(display_image, cmap='gray')&#10;    else:&#10;        plt.imshow(display_image)&#10;    plt.title(title)&#10;    plt.axis('off')&#10;    plt.show()&#10;&#10;&#10;class TorsoRoiPreprocessor(IPreprocessingStep):&#10;&#10;    def __init__(self, target_ratio):&#10;        self.target_ratio = target_ratio&#10;&#10;    def preprocess(self, image):&#10;        original_size = {&#10;            'height': image.shape[0],&#10;            'width': image.shape[1]&#10;        }&#10;        cropped_image, bbox = self.crop_torso_roi(image)&#10;        # show_image(cropped_image, &quot;1. Preprocess: Cropped Torso ROI&quot;)&#10;        cropped_and_padded_image, padding, padded_size = self.pad_image_to_correct_ratio(cropped_image, bbox)&#10;        # show_image(cropped_and_padded_image, &quot;2. Preprocess: Padded Image&quot;)&#10;        resized_image = self.rescale_image(cropped_and_padded_image, original_size, padded_size)&#10;        # show_image(resized_image, &quot;3. Preprocess: Resized Image (Final)&quot;)&#10;&#10;        parameters = {&#10;            'original_size': original_size,&#10;            'bbox': bbox,&#10;            'padding': padding,&#10;            'padded_size': padded_size,&#10;        }&#10;&#10;        return resized_image, parameters&#10;&#10;    def preprocess_with_parameters(self, image, parameters):&#10;        cropped_image = self.crop_with_parameters(image, parameters['bbox'])&#10;        # show_image(cropped_image, &quot;1. Preprocess w/ Params: Cropped&quot;)&#10;        cropped_and_padded_image = self.pad_image_with_parameters(cropped_image, parameters['padding'])&#10;        # show_image(cropped_and_padded_image, &quot;2. Preprocess w/ Params: Padded&quot;)&#10;        resized_image = self.rescale_image(cropped_and_padded_image, parameters['original_size'], parameters['padded_size'])&#10;        # show_image(resized_image, &quot;3. Preprocess w/ Params: Resized (Final)&quot;)&#10;        return resized_image&#10;&#10;    def undo_preprocessing(self, preprocessed_image, parameters):&#10;        show_image(preprocessed_image, &quot;0. Preprocessed Image&quot;)&#10;        cropped_and_padded_image = self.undo_rescale_image(preprocessed_image, parameters['original_size'], parameters['padded_size'])&#10;        show_image(cropped_and_padded_image, &quot;1. Undo: Un-rescaled&quot;)&#10;        cropped_image = self.undo_pad_image_to_correct_ratio(cropped_and_padded_image, parameters['padding'], parameters['padded_size'])&#10;        show_image(cropped_image, &quot;2. Undo: Un-padded&quot;)&#10;        image = self.undo_crop_torso_roi(cropped_image, parameters['original_size'], parameters['bbox'])&#10;        show_image(image, &quot;3. Undo: Un-cropped (Final)&quot;)&#10;        return image&#10;&#10;    @staticmethod&#10;    def crop_torso_roi(image):&#10;        image_rgb = image[..., :3]&#10;        torso_roi = np.any(image_rgb != [0, 0, 0], axis=-1)&#10;        coords = np.argwhere(torso_roi)&#10;        if coords.size == 0:&#10;            raise ValueError(&quot;No torso region found in the image.&quot;)&#10;        min_y, min_x = coords.min(axis=0)&#10;        max_y, max_x = coords.max(axis=0)&#10;        bbox = {&#10;            'min_x': min_x,&#10;            'max_x': max_x,&#10;            'min_y': min_y,&#10;            'max_y': max_y&#10;        }&#10;        cropped_image = image[min_y:max_y, min_x:max_x, ...]&#10;        return cropped_image, bbox&#10;&#10;    @staticmethod&#10;    def crop_with_parameters(image, bbox):&#10;        cropped_image = image[bbox['min_y']:bbox['max_y'], bbox['min_x']:bbox['max_x'], ...]&#10;        return cropped_image&#10;&#10;    @staticmethod&#10;    def undo_crop_torso_roi(cropped_image, original_size, bbox):&#10;        cropped_image_np = np.array(cropped_image)&#10;        resized_image_np = np.zeros(&#10;            (original_size['height'], original_size['width'], cropped_image_np.shape[2]),&#10;            dtype=cropped_image_np.dtype&#10;        )&#10;&#10;        min_y, min_x = bbox['min_y'], bbox['min_x']&#10;        height, width = cropped_image_np.shape[:2]&#10;&#10;        resized_image_np[min_y:min_y+height, min_x:min_x+width, ...] = cropped_image_np&#10;&#10;        return resized_image_np&#10;&#10;    def pad_image_to_correct_ratio(self, cropped_image, bbox):&#10;        width = bbox['max_x'] - bbox['min_x']&#10;        height = bbox['max_y'] - bbox['min_y']&#10;        current_ratio = width / height&#10;&#10;        if current_ratio &lt; self.target_ratio:&#10;            padded_width = int(round(height * self.target_ratio))&#10;            padded_height = height&#10;            pad_total = padded_width - width&#10;            pad_left = pad_total // 2&#10;            pad_right = pad_total - pad_left&#10;            pad_top = 0&#10;            pad_bottom = 0&#10;        elif current_ratio &gt; self.target_ratio:&#10;            padded_width = width&#10;            padded_height = int(round(width / self.target_ratio))&#10;            pad_total = padded_height - height&#10;            pad_left = 0&#10;            pad_right = 0&#10;            pad_top = pad_total // 2&#10;            pad_bottom = pad_total - pad_top&#10;        else:&#10;            padded_width = width&#10;            padded_height = height&#10;            pad_left = pad_right = pad_top = pad_bottom = 0&#10;&#10;        padding = {&#10;            'left': pad_left,&#10;            'right': pad_right,&#10;            'top': pad_top,&#10;            'bottom': pad_bottom&#10;        }&#10;&#10;        padded_size = {&#10;            'width': padded_width,&#10;            'height': padded_height&#10;        }&#10;&#10;        padded_image = np.pad(&#10;            cropped_image,&#10;            ((padding['top'], padding['bottom']), (padding['left'], padding['right']), (0, 0)),&#10;            mode='constant',&#10;            constant_values=0&#10;        )&#10;        return padded_image, padding, padded_size&#10;&#10;    @staticmethod&#10;    def pad_image_with_parameters(cropped_image, padding):&#10;        padded_image = np.pad(&#10;            cropped_image,&#10;            ((padding['top'], padding['bottom']), (padding['left'], padding['right']), (0, 0)),&#10;            mode='constant',&#10;            constant_values=0&#10;        )&#10;        return padded_image&#10;&#10;    @staticmethod&#10;    def undo_pad_image_to_correct_ratio(padded_image, padding, padded_size):&#10;        top, bottom = padding['top'], padding['bottom']&#10;        left, right = padding['left'], padding['right']&#10;        height, width = padded_image.shape[:2]&#10;        unpadded_image = padded_image[&#10;            top:height - bottom if bottom &gt; 0 else height,&#10;            left:width - right if right &gt; 0 else width,&#10;            ...&#10;        ]&#10;        return unpadded_image&#10;&#10;    @staticmethod&#10;    def rescale_image(cropped_and_padded_image, original_size, padded_size):&#10;        output_shape = (original_size['height'], original_size['width'], cropped_and_padded_image.shape[2])&#10;        rescaled_image = resize(&#10;            cropped_and_padded_image,&#10;            output_shape,&#10;            order=1,  # bilinear&#10;            mode='constant',&#10;            cval=0,&#10;            anti_aliasing=True,&#10;            preserve_range=True&#10;        ).astype(cropped_and_padded_image.dtype)&#10;        return rescaled_image&#10;&#10;    @staticmethod&#10;    def undo_rescale_image(rescaled_image, original_size, padded_size):&#10;        # Automatically detect image type (color, grayscale, or binary)&#10;        is_binary = len(np.unique(rescaled_image)) &lt;= 2&#10;&#10;        if rescaled_image.ndim == 3:&#10;            # Color image&#10;            output_shape = (padded_size['height'], padded_size['width'], rescaled_image.shape[2])&#10;            order = 1  # Bilinear for color&#10;            anti_aliasing = True&#10;        elif rescaled_image.ndim == 2:&#10;            # Grayscale or binary image&#10;            output_shape = (padded_size['height'], padded_size['width'])&#10;            if is_binary:&#10;                order = 0  # Nearest-neighbor for binary&#10;                anti_aliasing = False&#10;            else:&#10;                order = 1  # Bilinear for grayscale&#10;                anti_aliasing = True&#10;        else:&#10;            raise ValueError(f&quot;Unsupported image ndim: {rescaled_image.ndim}. Image must be 2D or 3D.&quot;)&#10;&#10;        unscaled_image = resize(&#10;            rescaled_image,&#10;            output_shape,&#10;            order=order,&#10;            mode='constant',&#10;            cval=0,&#10;            anti_aliasing=anti_aliasing,&#10;            preserve_range=True&#10;        ).astype(rescaled_image.dtype)&#10;        return unscaled_image&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;from skimage.transform import resize&#10;import matplotlib.pyplot as plt&#10;&#10;from preprocessing.preprocessing_step import IPreprocessingStep&#10;&#10;&#10;def show_image(image, title=&quot;&quot;):&#10;    &quot;&quot;&quot;Helper function to display an image.&quot;&quot;&quot;&#10;    display_image = (image * 255).astype(np.uint8)&#10;    if image.ndim == 2:&#10;        plt.imshow(display_image, cmap='gray')&#10;    else:&#10;        plt.imshow(display_image)&#10;    plt.title(title)&#10;    plt.axis('off')&#10;    plt.show()&#10;&#10;&#10;class TorsoRoiPreprocessor(IPreprocessingStep):&#10;&#10;    def __init__(self, target_ratio):&#10;        self.target_ratio = target_ratio&#10;&#10;    def preprocess(self, image):&#10;        original_size = {&#10;            'height': image.shape[0],&#10;            'width': image.shape[1]&#10;        }&#10;        cropped_image, bbox = self.crop_torso_roi(image)&#10;        # show_image(cropped_image, &quot;1. Preprocess: Cropped Torso ROI&quot;)&#10;        cropped_and_padded_image, padding, padded_size = self.pad_image_to_correct_ratio(cropped_image, bbox)&#10;        # show_image(cropped_and_padded_image, &quot;2. Preprocess: Padded Image&quot;)&#10;        resized_image = self.rescale_image(cropped_and_padded_image, original_size, padded_size)&#10;        # show_image(resized_image, &quot;3. Preprocess: Resized Image (Final)&quot;)&#10;&#10;        parameters = {&#10;            'original_size': original_size,&#10;            'bbox': bbox,&#10;            'padding': padding,&#10;            'padded_size': padded_size,&#10;        }&#10;&#10;        return resized_image, parameters&#10;&#10;    def preprocess_with_parameters(self, image, parameters):&#10;        cropped_image = self.crop_with_parameters(image, parameters['bbox'])&#10;        # show_image(cropped_image, &quot;1. Preprocess w/ Params: Cropped&quot;)&#10;        cropped_and_padded_image = self.pad_image_with_parameters(cropped_image, parameters['padding'])&#10;        # show_image(cropped_and_padded_image, &quot;2. Preprocess w/ Params: Padded&quot;)&#10;        resized_image = self.rescale_image(cropped_and_padded_image, parameters['original_size'], parameters['padded_size'])&#10;        # show_image(resized_image, &quot;3. Preprocess w/ Params: Resized (Final)&quot;)&#10;        return resized_image&#10;&#10;    def undo_preprocessing(self, preprocessed_image, parameters):&#10;        show_image(preprocessed_image, &quot;0. Preprocessed Image&quot;)&#10;        cropped_and_padded_image = self.undo_rescale_image(preprocessed_image, parameters['original_size'], parameters['padded_size'])&#10;        show_image(cropped_and_padded_image, &quot;1. Undo: Un-rescaled&quot;)&#10;        cropped_image = self.undo_pad_image_to_correct_ratio(cropped_and_padded_image, parameters['padding'], parameters['padded_size'])&#10;        show_image(cropped_image, &quot;2. Undo: Un-padded&quot;)&#10;        image = self.undo_crop_torso_roi(cropped_image, parameters['original_size'], parameters['bbox'])&#10;        show_image(image, &quot;3. Undo: Un-cropped (Final)&quot;)&#10;        return image&#10;&#10;    @staticmethod&#10;    def crop_torso_roi(image):&#10;        image_rgb = image[..., :3]&#10;        torso_roi = np.any(image_rgb != [0, 0, 0], axis=-1)&#10;        coords = np.argwhere(torso_roi)&#10;        if coords.size == 0:&#10;            raise ValueError(&quot;No torso region found in the image.&quot;)&#10;        min_y, min_x = coords.min(axis=0)&#10;        max_y, max_x = coords.max(axis=0)&#10;        bbox = {&#10;            'min_x': min_x,&#10;            'max_x': max_x,&#10;            'min_y': min_y,&#10;            'max_y': max_y&#10;        }&#10;        cropped_image = image[min_y:max_y, min_x:max_x, ...]&#10;        return cropped_image, bbox&#10;&#10;    @staticmethod&#10;    def crop_with_parameters(image, bbox):&#10;        cropped_image = image[bbox['min_y']:bbox['max_y'], bbox['min_x']:bbox['max_x'], ...]&#10;        return cropped_image&#10;&#10;    @staticmethod&#10;    def undo_crop_torso_roi(cropped_image, original_size, bbox):&#10;        cropped_image_np = np.array(cropped_image)&#10;        resized_image_np = np.zeros(&#10;            (original_size['height'], original_size['width'], cropped_image_np.shape[2]),&#10;            dtype=cropped_image_np.dtype&#10;        )&#10;&#10;        min_y, min_x = bbox['min_y'], bbox['min_x']&#10;        height, width = cropped_image_np.shape[:2]&#10;&#10;        resized_image_np[min_y:min_y+height, min_x:min_x+width, ...] = cropped_image_np&#10;&#10;        return resized_image_np&#10;&#10;    def pad_image_to_correct_ratio(self, cropped_image, bbox):&#10;        width = bbox['max_x'] - bbox['min_x']&#10;        height = bbox['max_y'] - bbox['min_y']&#10;        current_ratio = width / height&#10;&#10;        if current_ratio &lt; self.target_ratio:&#10;            padded_width = int(round(height * self.target_ratio))&#10;            padded_height = height&#10;            pad_total = padded_width - width&#10;            pad_left = pad_total // 2&#10;            pad_right = pad_total - pad_left&#10;            pad_top = 0&#10;            pad_bottom = 0&#10;        elif current_ratio &gt; self.target_ratio:&#10;            padded_width = width&#10;            padded_height = int(round(width / self.target_ratio))&#10;            pad_total = padded_height - height&#10;            pad_left = 0&#10;            pad_right = 0&#10;            pad_top = pad_total // 2&#10;            pad_bottom = pad_total - pad_top&#10;        else:&#10;            padded_width = width&#10;            padded_height = height&#10;            pad_left = pad_right = pad_top = pad_bottom = 0&#10;&#10;        padding = {&#10;            'left': pad_left,&#10;            'right': pad_right,&#10;            'top': pad_top,&#10;            'bottom': pad_bottom&#10;        }&#10;&#10;        padded_size = {&#10;            'width': padded_width,&#10;            'height': padded_height&#10;        }&#10;&#10;        padded_image = np.pad(&#10;            cropped_image,&#10;            ((padding['top'], padding['bottom']), (padding['left'], padding['right']), (0, 0)),&#10;            mode='constant',&#10;            constant_values=0&#10;        )&#10;        return padded_image, padding, padded_size&#10;&#10;    @staticmethod&#10;    def pad_image_with_parameters(cropped_image, padding):&#10;        padded_image = np.pad(&#10;            cropped_image,&#10;            ((padding['top'], padding['bottom']), (padding['left'], padding['right']), (0, 0)),&#10;            mode='constant',&#10;            constant_values=0&#10;        )&#10;        return padded_image&#10;&#10;    @staticmethod&#10;    def undo_pad_image_to_correct_ratio(padded_image, padding, padded_size):&#10;        top, bottom = padding['top'], padding['bottom']&#10;        left, right = padding['left'], padding['right']&#10;        height, width = padded_image.shape[:2]&#10;        unpadded_image = padded_image[&#10;            top:height - bottom if bottom &gt; 0 else height,&#10;            left:width - right if right &gt; 0 else width,&#10;            ...&#10;        ]&#10;        return unpadded_image&#10;&#10;    @staticmethod&#10;    def rescale_image(cropped_and_padded_image, original_size, padded_size):&#10;        output_shape = (original_size['height'], original_size['width'], cropped_and_padded_image.shape[2])&#10;        rescaled_image = resize(&#10;            cropped_and_padded_image,&#10;            output_shape,&#10;            order=1,  # bilinear&#10;            mode='constant',&#10;            cval=0,&#10;            anti_aliasing=True,&#10;            preserve_range=True&#10;        ).astype(cropped_and_padded_image.dtype)&#10;        return rescaled_image&#10;&#10;    @staticmethod&#10;    def undo_rescale_image(rescaled_image, original_size, padded_size):&#10;        # Automatically detect image type (color, grayscale, or binary)&#10;        is_binary = len(np.unique(rescaled_image)) &lt;= 2&#10;&#10;        if rescaled_image.ndim == 3:&#10;            # Color image&#10;            output_shape = (padded_size['height'], padded_size['width'], rescaled_image.shape[2])&#10;            order = 1  # Bilinear for color&#10;            anti_aliasing = True&#10;        elif rescaled_image.ndim == 2:&#10;            # Grayscale or binary image&#10;            output_shape = (padded_size['height'], padded_size['width'])&#10;            if is_binary:&#10;                order = 0  # Nearest-neighbor for binary&#10;                anti_aliasing = False&#10;            else:&#10;                order = 1  # Bilinear for grayscale&#10;                anti_aliasing = True&#10;        else:&#10;            raise ValueError(f&quot;Unsupported image ndim: {rescaled_image.ndim}. Image must be 2D or 3D.&quot;)&#10;&#10;        unscaled_image = resize(&#10;            rescaled_image,&#10;            output_shape,&#10;            order=order,&#10;            mode='constant',&#10;            cval=0,&#10;            anti_aliasing=anti_aliasing,&#10;            preserve_range=True&#10;        ).astype(rescaled_image.dtype)&#10;        return unscaled_image" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>