<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/SegmentationRunner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SegmentationRunner.py" />
              <option name="originalContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
              <option name="updatedContent" value="from atlas.refiner.color_patch_refiner import ColorPatchRefiner&#10;from atlas.selector.bmi_atlas_selector import BmiAtlasSelector&#10;from atlas.selector.similarity_atlas_selector import SimilarityAtlasSelector&#10;from atlas.voter.majority_voter import MajorityVoter&#10;from atlas.voter.weighted_majority_voter import WeightedMajorityVoter&#10;from preprocessing.blue_color_preprocessor import BlueColorPreprocessor&#10;from preprocessing.color_preprocessor import ColorPreprocessor&#10;from preprocessing.dimples_roi_preprocessor import DimplesRoiPreprocessor&#10;from preprocessing.torso_roi_preprocessor import TorsoRoiPreprocessor&#10;from segmenter.atlas_segmenter import AtlasSegmenter&#10;import time&#10;import os&#10;&#10;&#10;class AtlasSegmentationRunner:&#10;    def __init__(self, num_atlases_to_select, atlas_dir, preprocessing_steps, atlas_selector, segmentation_voter, segmentation_refiner, output_dir, target_images_dir):&#10;        self.segmenter = AtlasSegmenter(&#10;            num_atlases_to_select,&#10;            atlas_dir,&#10;            preprocessing_steps,&#10;            atlas_selector,&#10;            segmentation_voter,&#10;            segmentation_refiner,&#10;            output_dir&#10;        )&#10;        self.target_images_dir = target_images_dir&#10;&#10;    def run(self):&#10;        # start timing&#10;        start_time = time.time()&#10;        target_images = self.segmenter.load_target_images(self.target_images_dir)&#10;        segmented_images = self.segmenter.segment_images(target_images)&#10;        self.segmenter.save_segmentation(segmented_images)&#10;        # end timing and compute durations&#10;        end_time = time.time()&#10;        total_seconds = end_time - start_time&#10;        # format total duration h:m:s&#10;        hrs = int(total_seconds // 3600)&#10;        mins = int((total_seconds % 3600) // 60)&#10;        secs = int(total_seconds % 60)&#10;        duration_str = f&quot;{hrs:02d}:{mins:02d}:{secs:02d}&quot;&#10;        # average per image&#10;        num_images = len(target_images)&#10;        if num_images &gt; 0:&#10;            avg_seconds = total_seconds / num_images&#10;            avg_hrs = int(avg_seconds // 3600)&#10;            avg_mins = int((avg_seconds % 3600) // 60)&#10;            avg_secs = int(avg_seconds % 60)&#10;            avg_str = f&quot;{avg_hrs:02d}:{avg_mins:02d}:{avg_secs:02d}&quot;&#10;        else:&#10;            avg_str = &quot;00:00:00&quot;&#10;        # write durations to file in output_dir&#10;        duration_file = os.path.join(self.segmenter.output_dir, &quot;duration.txt&quot;)&#10;        with open(duration_file, &quot;w&quot;) as f:&#10;            f.write(f&quot;Total duration: {duration_str}\n&quot;)&#10;            f.write(f&quot;Average per image: {avg_str}\n&quot;)&#10;&#10;# Beispiel für die Ausführung:&#10;if __name__ == &quot;__main__&quot;:&#10;    # Hier müssen die passenden Objekte und Parameter übergeben werden&#10;    runner = AtlasSegmentationRunner(&#10;        num_atlases_to_select=13,&#10;        atlas_dir=&quot;data/Atlas_Data_BMI_Percentile&quot;,&#10;        # preprocessing_steps=[DimplesRoiPreprocessor(target_ratio=10/7) ,BlueColorPreprocessor()],  # Liste mit Preprocessing-Objekten&#10;        preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;        atlas_selector=BmiAtlasSelector(&quot;data/Info_Sheets/All_Data_Renamed_overview.csv&quot;, &quot;data/Info_Sheets/bmi_table_who.csv&quot;),      # AtlasSelector-Objekt&#10;        segmentation_voter=WeightedMajorityVoter(scheme=&quot;softmax&quot;, temperature=0.02, threshold=0.5),  # SegmentationVoter-Objekt&#10;        segmentation_refiner=ColorPatchRefiner(BlueColorPreprocessor()),&#10;        output_dir=&quot;data/Atlas_Experiment100&quot;,&#10;        target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    )&#10;    # runner = AtlasSegmentationRunner(&#10;    #     num_atlases_to_select=3,&#10;    #     atlas_dir=&quot;data/Atlas_Data&quot;,&#10;    #     preprocessing_steps=[],  # Liste mit Preprocessing-Objekten&#10;    #     atlas_selector=SimilarityAtlasSelector(),      # AtlasSelector-Objekt&#10;    #     segmentation_voter=MajorityVoter(),  # SegmentationVoter-Objekt&#10;    #     segmentation_refiner=None,&#10;    #     output_dir=&quot;data/Atlas_Experiment01&quot;,&#10;    #     target_images_dir=&quot;data/Validation_Data_Small&quot;&#10;    # )&#10;    runner.run()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/atlas/refiner/color_patch_refiner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/atlas/refiner/color_patch_refiner.py" />
              <option name="originalContent" value="import numpy as np&#10;from scipy.ndimage import binary_propagation&#10;import matplotlib.pyplot as plt&#10;&#10;from atlas.refiner.segmentation_refiner import ISegmentationRefiner&#10;&#10;&#10;class ColorPatchRefiner(ISegmentationRefiner):&#10;&#10;    def __init__(self, color_preprocessor):&#10;        self.color_preprocessor = color_preprocessor&#10;&#10;    def refine(self, target_segmentation, target_image):&#10;        if target_segmentation.max() == 0:&#10;            return target_segmentation&#10;&#10;        # Get the color range mask and set it to 3 channels (0/1)&#10;        target_color_mask, _ = self.color_preprocessor.preprocess_image(target_image.image)&#10;        # Debug: display target_color_mask with original colors&#10;        orig_colors = target_image.image[..., :3]&#10;        colored_mask = np.zeros_like(orig_colors)&#10;        mask_bool = target_color_mask &gt; 0&#10;        colored_mask[mask_bool] = orig_colors[mask_bool]&#10;        plt.figure()&#10;        plt.imshow(colored_mask)&#10;        plt.title('Target Color Mask with Original Colors')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        target_color_mask = (np.repeat(target_color_mask[:, :, np.newaxis], 3, axis=2) // 255).astype(np.uint8)&#10;        # Debug: display the normalized 3-channel mask&#10;        plt.figure()&#10;        plt.imshow(target_color_mask * 255)&#10;        plt.title('Normalized 3-Channel Binary Mask (0/1)')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # 2D boolean masks&#10;        if target_segmentation.ndim == 2:&#10;            target_segmentation_bool = target_segmentation &gt; 0  # [H,W]&#10;            was_2d = True&#10;            C_in = 1&#10;        elif target_segmentation.ndim == 3:&#10;            was_2d = False&#10;            C_in = target_segmentation.shape[2]&#10;            if C_in == 1:&#10;                target_segmentation_bool = target_segmentation[..., 0] &gt; 0&#10;            else:&#10;                target_segmentation_bool = np.any(target_segmentation &gt; 0, axis=2)  # [H,W]&#10;        else:&#10;            raise ValueError(f&quot;Unexpected target_segmentation shape: {target_segmentation.shape}&quot;)&#10;&#10;        target_color_bool = np.any(target_color_mask &gt; 0, axis=2)  # [H,W]&#10;        # Debug: display 2D boolean mask of color area&#10;        plt.figure()&#10;        plt.imshow(target_color_bool, cmap='gray')&#10;        plt.title('2D Boolean Mask of Color Area')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Starting points: Intersection&#10;        seed = target_segmentation_bool &amp; target_color_bool&#10;        # Debug: display seed mask (intersection)&#10;        plt.figure()&#10;        plt.imshow(seed, cmap='gray')&#10;        plt.title('Seed (Intersection Mask)')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Region growing within target_color_bool (8-neighborhood)&#10;        grown_region = binary_propagation(seed, mask=target_color_bool, structure=np.ones((3, 3), bool))&#10;        # Debug: display grown_region mask (after propagation)&#10;        plt.figure()&#10;        plt.imshow(grown_region, cmap='gray')&#10;        plt.title('Grown Region After Binary Propagation')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Result = original segmentation ∪ grown_region region&#10;        refined_segmentation_bool = target_segmentation_bool | grown_region&#10;        # Debug: display refined segmentation boolean mask&#10;        plt.figure()&#10;        plt.imshow(refined_segmentation_bool, cmap='gray')&#10;        plt.title('Refined Segmentation Bool (Intersection ∪ Grown Region)')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Back in 3-channel form (1 white, 0 black)&#10;        white_val = target_segmentation.max()&#10;        if was_2d:&#10;            refined = np.zeros_like(target_segmentation)&#10;            refined[refined_segmentation_bool] = white_val&#10;            return refined&#10;        else:&#10;            refined_segmentation = np.zeros_like(target_segmentation)&#10;            if C_in == 1:&#10;                refined_segmentation[..., 0][refined_segmentation_bool] = white_val&#10;            else:&#10;                for c in range(C_in):&#10;                    refined_segmentation[..., c][refined_segmentation_bool] = white_val&#10;            return refined_segmentation&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;from scipy.ndimage import binary_propagation&#10;import matplotlib.pyplot as plt&#10;&#10;from atlas.refiner.segmentation_refiner import ISegmentationRefiner&#10;&#10;&#10;class ColorPatchRefiner(ISegmentationRefiner):&#10;&#10;    def __init__(self, color_preprocessor):&#10;        self.color_preprocessor = color_preprocessor&#10;&#10;    def refine(self, target_segmentation, target_image):&#10;        if target_segmentation.max() == 0:&#10;            return target_segmentation&#10;&#10;        # Get the color range mask and set it to 3 channels (0/1)&#10;        target_color_mask, _ = self.color_preprocessor.preprocess_image(target_image.image)&#10;        # Debug: display target_color_mask with original colors&#10;        orig_colors = target_image.image[..., :3]&#10;        colored_mask = np.zeros_like(orig_colors)&#10;        mask_bool = target_color_mask &gt; 0&#10;        colored_mask[mask_bool] = orig_colors[mask_bool]&#10;        plt.figure()&#10;        plt.imshow(colored_mask)&#10;        plt.title('Target Color Mask with Original Colors')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        target_color_mask = (np.repeat(target_color_mask[:, :, np.newaxis], 3, axis=2) // 255).astype(np.uint8)&#10;        # Debug: display the normalized 3-channel mask&#10;        plt.figure()&#10;        plt.imshow(target_color_mask * 255)&#10;        plt.title('Normalized 3-Channel Binary Mask (0/1)')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # 2D boolean masks&#10;        if target_segmentation.ndim == 2:&#10;            target_segmentation_bool = target_segmentation &gt; 0  # [H,W]&#10;            was_2d = True&#10;            C_in = 1&#10;        elif target_segmentation.ndim == 3:&#10;            was_2d = False&#10;            C_in = target_segmentation.shape[2]&#10;            if C_in == 1:&#10;                target_segmentation_bool = target_segmentation[..., 0] &gt; 0&#10;            else:&#10;                target_segmentation_bool = np.any(target_segmentation &gt; 0, axis=2)  # [H,W]&#10;        else:&#10;            raise ValueError(f&quot;Unexpected target_segmentation shape: {target_segmentation.shape}&quot;)&#10;&#10;        target_color_bool = np.any(target_color_mask &gt; 0, axis=2)  # [H,W]&#10;        # Debug: display 2D boolean mask of color area&#10;        plt.figure()&#10;        plt.imshow(target_color_bool, cmap='gray')&#10;        plt.title('2D Boolean Mask of Color Area')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Starting points: Intersection&#10;        seed = target_segmentation_bool &amp; target_color_bool&#10;        # Debug: display seed mask (intersection)&#10;        plt.figure()&#10;        plt.imshow(seed, cmap='gray')&#10;        plt.title('Seed (Intersection Mask)')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Region growing within target_color_bool (8-neighborhood)&#10;        grown_region = binary_propagation(seed, mask=target_color_bool, structure=np.ones((3, 3), bool))&#10;        # Debug: display grown_region mask (after propagation)&#10;        plt.figure()&#10;        plt.imshow(grown_region, cmap='gray')&#10;        plt.title('Grown Region After Binary Propagation')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Result = original segmentation ∪ grown_region region&#10;        refined_segmentation_bool = target_segmentation_bool | grown_region&#10;        # Debug: display refined segmentation boolean mask&#10;        plt.figure()&#10;        plt.imshow(refined_segmentation_bool, cmap='gray')&#10;        plt.title('Refined Segmentation Bool (Intersection ∪ Grown Region)')&#10;        plt.axis('off')&#10;        plt.show()&#10;&#10;        # Back in 3-channel form (1 white, 0 black)&#10;        white_val = target_segmentation.max()&#10;        if was_2d:&#10;            refined = np.zeros_like(target_segmentation)&#10;            refined[refined_segmentation_bool] = white_val&#10;            return refined&#10;        else:&#10;            refined_segmentation = np.zeros_like(target_segmentation)&#10;            if C_in == 1:&#10;                refined_segmentation[..., 0][refined_segmentation_bool] = white_val&#10;            else:&#10;                for c in range(C_in):&#10;                    refined_segmentation[..., c][refined_segmentation_bool] = white_val&#10;            return refined_segmentation" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>